"""
This type stub file was generated by pyright.
"""

import contextlib
import platform
from typing import Optional
from yolov5.utils import TryExcept

"""
General utils
"""
FILE = ...
ROOT = ...
RANK = ...
NUM_THREADS = ...
DATASETS_DIR = ...
AUTOINSTALL = ...
VERBOSE = ...
TQDM_BAR_FORMAT = ...
FONT = ...
def is_ascii(s=...): # -> bool:
    ...

def is_chinese(s=...): # -> bool:
    ...

def is_colab(): # -> bool:
    ...

def is_notebook(): # -> bool:
    ...

def is_kaggle(): # -> bool:
    ...

def is_docker() -> bool:
    """Check if the process runs inside a docker container."""
    ...

def is_writeable(dir, test=...): # -> bool:
    ...

LOGGING_NAME = ...
def set_logging(name=..., verbose=...): # -> None:
    ...

LOGGER = ...
if platform.system() == 'Windows':
    ...
def user_config_dir(dir=..., env_var=...): # -> Path:
    ...

CONFIG_DIR = ...
class Profile(contextlib.ContextDecorator):
    def __init__(self, t=...) -> None:
        ...
    
    def __enter__(self): # -> Self@Profile:
        ...
    
    def __exit__(self, type, value, traceback): # -> None:
        ...
    
    def time(self): # -> float:
        ...
    


class Timeout(contextlib.ContextDecorator):
    def __init__(self, seconds, *, timeout_msg=..., suppress_timeout_errors=...) -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb): # -> Literal[True] | None:
        ...
    


class WorkingDirectory(contextlib.ContextDecorator):
    def __init__(self, new_dir) -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb): # -> None:
        ...
    


def methods(instance): # -> list[str]:
    ...

def print_args(args: Optional[dict] = ..., show_file=..., show_func=...): # -> None:
    ...

def init_seeds(seed=..., deterministic=...): # -> None:
    ...

def intersect_dicts(da, db, exclude=...): # -> dict[Unknown, Unknown]:
    ...

def get_default_args(func): # -> dict[str, Any]:
    ...

def get_latest_run(search_dir=...): # -> str:
    ...

def file_age(path=...): # -> int:
    ...

def file_date(path=...): # -> str:
    ...

def file_size(path): # -> float:
    ...

def check_online(): # -> bool:
    ...

def git_describe(path=...): # -> str:
    ...

@TryExcept()
@WorkingDirectory(ROOT)
def check_git_status(repo=..., branch=...): # -> None:
    ...

@WorkingDirectory(ROOT)
def check_git_info(path=...): # -> dict[str, str | None] | dict[str, None]:
    ...

def check_python(minimum=...): # -> None:
    ...

def check_version(current=..., minimum=..., name=..., pinned=..., hard=..., verbose=...): # -> Any:
    ...

@TryExcept()
def check_requirements(requirements=..., exclude=..., install=..., cmds=...): # -> None:
    ...

def check_img_size(imgsz, s=..., floor=...): # -> int | list[int]:
    ...

def check_imshow(warn=...): # -> bool:
    ...

def check_suffix(file=..., suffix=..., msg=...): # -> None:
    ...

def check_yaml(file, suffix=...): # -> str:
    ...

def check_file(file, suffix=...): # -> str:
    ...

def check_font(font=..., progress=...): # -> None:
    ...

def check_dataset(data, autodownload=...): # -> Any:
    ...

def check_amp(model): # -> bool:
    ...

def yaml_load(file=...): # -> Any:
    ...

def yaml_save(file=..., data=...): # -> None:
    ...

def unzip_file(file, path=..., exclude=...): # -> None:
    ...

def url2file(url): # -> str:
    ...

def download(url, dir=..., unzip=..., delete=..., curl=..., threads=..., retry=...): # -> None:
    ...

def make_divisible(x, divisor):
    ...

def clean_str(s): # -> str:
    ...

def one_cycle(y1=..., y2=..., steps=...): # -> (x: Unknown) -> float:
    ...

def colorstr(*input): # -> str:
    ...

def labels_to_class_weights(labels, nc=...): # -> Tensor:
    ...

def labels_to_image_weights(labels, nc=..., class_weights=...): # -> Any:
    ...

def coco80_to_coco91_class(): # -> list[int]:
    ...

def xyxy2xywh(x): # -> Tensor | NDArray[Unknown]:
    ...

def xywh2xyxy(x): # -> Tensor | NDArray[Unknown]:
    ...

def xywhn2xyxy(x, w=..., h=..., padw=..., padh=...): # -> Tensor | NDArray[Unknown]:
    ...

def xyxy2xywhn(x, w=..., h=..., clip=..., eps=...): # -> Tensor | NDArray[Unknown]:
    ...

def xyn2xy(x, w=..., h=..., padw=..., padh=...): # -> Tensor | NDArray[Unknown]:
    ...

def segment2box(segment, width=..., height=...): # -> NDArray[Unknown] | NDArray[float64]:
    ...

def segments2boxes(segments): # -> Tensor | NDArray[Unknown]:
    ...

def resample_segments(segments, n=...):
    ...

def scale_boxes(img1_shape, boxes, img0_shape, ratio_pad=...):
    ...

def scale_segments(img1_shape, segments, img0_shape, ratio_pad=..., normalize=...):
    ...

def clip_boxes(boxes, shape): # -> None:
    ...

def clip_segments(segments, shape): # -> None:
    ...

def non_max_suppression(prediction, conf_thres=..., iou_thres=..., classes=..., agnostic=..., multi_label=..., labels=..., max_det=..., nm=...):
    """Non-Maximum Suppression (NMS) on inference results to reject overlapping detections

    Returns:
         list of detections, on (n,6) tensor per image [xyxy, conf, cls]
    """
    ...

def strip_optimizer(f=..., s=...): # -> None:
    ...

def print_mutation(keys, results, hyp, save_dir, bucket, prefix=...): # -> None:
    ...

def apply_classifier(x, model, img, im0):
    ...

def increment_path(path, exist_ok=..., sep=..., mkdir=...): # -> Path:
    ...

imshow_ = ...
def imread(path, flags=...): # -> Any:
    ...

def imwrite(path, im): # -> bool:
    ...

def imshow(path, im): # -> None:
    ...

